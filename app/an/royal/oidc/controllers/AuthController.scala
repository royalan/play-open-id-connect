package an.royal.oidc.controllers

import javax.inject._

import akka.stream.Materializer
import akka.stream.scaladsl.{Sink, Source}
import an.royal.oidc.constants.ErrorCodes.ErrorCode
import an.royal.oidc.constants.{ErrorCodes, OpenIDDisplay, OpenIDPrompt, OpenIDResponseType}
import an.royal.oidc.dtos.ClientAuthReq
import an.royal.oidc.repositories.{Client, ClientRepository, TokenRepository, UserConsentRepository}
import an.royal.oidc.services.{SessionService, TokenService}
import an.royal.oidc.{InvalidSessionException, OpenIDException}
import play.api.Logger
import play.api.mvc._

import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Success, Try}

@Singleton
class AuthController @Inject()(userInfoAction: UserInfoAction, tokenRepository: TokenRepository, clientRepository: ClientRepository, userConsentRepository: UserConsentRepository,
                               tokenService: TokenService, sessionService: SessionService, cc: ControllerComponents)
                              (implicit mat: Materializer, ec: ExecutionContext) extends AbstractController(cc) {

  import an.royal.oidc.dtos.HttpBaseResponse._

  /**
    * @param client_id     - client ID
    * @param response_type - OpenIDResponseType
    * @param scope         - scopes own by client
    * @param redirect_uri  - redirect URI
    * @param nonce         - a random value generated by your app that enables replay protection when present and will be include in ID_TOKEN as nonce parameter.
    * @param state         - Opaque value used to maintain state between the request and the callback.
    * @param prompt        - OpenIDPrompt
    * @param display       - OpenIDDisplay
    * @return Asynchronous response
    */
  def auth(client_id: String, response_type: String, scope: String, redirect_uri: String, nonce: String,
           state: Option[String], prompt: Option[String], display: Option[String]): Action[AnyContent] = Action.async { implicit req =>

    def validateReq(client: Client) =
      if (client.redirectURIs.contains(redirect_uri.trim)) {
        val validParams = for {
          validTypes <- Try(response_type.split(" +").map(_.toLowerCase).map(OpenIDResponseType.withName).toSet)
          validScopes <- Try(scope.split(" ").map(_.trim.toLowerCase).toSet).filter(_.subsetOf(client.scopes.toSet))
          validPrompt <- Try(prompt.map(OpenIDPrompt.withName))
          validDisplay <- Try(display.map(OpenIDDisplay.withName))
        } yield {
          ClientAuthReq(client_id, validTypes, validScopes, redirect_uri, nonce, state, validPrompt, validDisplay)
        }

        validParams match {
          case Success(r) => Right(r, client)
          case Failure(e) =>
            Logger.debug("Got exception while checking parameters of request.", e)
            Left(ErrorCodes.INVALID_REQUEST_OBJECT)
        }
      } else {
        Left(ErrorCodes.INVALID_REDIRECT_URI)
      }


    // ------------------- begin --------------------- //
    Source.fromFuture(clientRepository.findByClientID(client_id))
      .map {
        case Some(client) => validateReq(client)
        case None =>
          Left(ErrorCodes.INVALID_CLIENT_ID)
      }
      .mapAsync(1) {
        case Right((validReq, client)) =>

          val userID = sessionService.checkSession(req.session.get("sessionID"), req.cookies.get("token").map(_.value)).map(_.getSubject)

          validatePrompt(validReq, userID).flatMap {
            case OpenIDPrompt.NONE =>

              // TODO check response_type? should we manage it?
              val tokens = validReq.responseTypes
                .filter(_ != OpenIDResponseType.NONE)
                .map {
                  case OpenIDResponseType.CODE => tokenService.createGrantCode(validReq.clientID).map("code" -> Seq(_))
                  case OpenIDResponseType.TOKEN => userID.flatMap(tokenService.createAccessToken).map("token" -> Seq(_))
                  case OpenIDResponseType.ID_TOKEN => userID.flatMap(uid => tokenService.createIDToken(uid, validReq.clientID, nonce)).map("id_token" -> Seq(_))
                }

              Future.sequence(tokens)
                .map(qSet => state.map(s => qSet + ("state" -> Seq(s))).getOrElse(qSet))
                .map(qSet =>
                  qSet.collectFirst{
                    case ("token", _) | ("id_token", _) =>
                      Redirect(Call("get", redirect_uri, qSet.foldLeft("")((o, v) => o + s"${v._1}=${v._2.head}&").dropRight(1)))
                    case _ =>
                      Redirect(redirect_uri, qSet.toMap)
                  }.get)

            case OpenIDPrompt.CONSENT =>
              // TODO make consent form
              Logger.debug(s"Pre-request URI: ${req.uri}")
              Future.successful(Ok(views.html.consent()).withSession(req.session + ("preReq" -> req.uri)))
          }

        case Left(err) => Future.successful(
          if (err == ErrorCodes.INVALID_REDIRECT_URI)
            errorResponse(BAD_REQUEST, err)
          else
            Redirect(redirect_uri, authErrorQueryParams(err, state)))
      }
      .runWith(Sink.head)
  }


  // ---------------- common functions -------------------- //

  private def authErrorQueryParams(errorCode: ErrorCode, state: Option[String]): Map[String, Seq[String]] = state match {
    case Some(s) => Map("error" -> Seq(errorCode.toString.toLowerCase), "state" -> Seq(s))
    case None => Map("error" -> Seq(errorCode.toString.toLowerCase))
  }


  private def validatePrompt(validReq: ClientAuthReq, userID: Future[String]): Future[OpenIDPrompt.Prompt] =
    validReq.prompt map {
      case OpenIDPrompt.NONE =>
        userID.flatMap(uid => checkConsentScopes(uid, validReq.clientID, validReq.scopes))
          .map {
            case OpenIDPrompt.CONSENT => throw OpenIDException(ErrorCodes.CONSENT_REQUIRED)
            case OpenIDPrompt.LOGIN => throw OpenIDException(ErrorCodes.LOGIN_REQUIRED)
            case p => p
          }.recover { case _: InvalidSessionException => throw OpenIDException(ErrorCodes.LOGIN_REQUIRED) }

      case OpenIDPrompt.CONSENT =>
        userID.map(_ => OpenIDPrompt.CONSENT).recover { case _: InvalidSessionException => throw OpenIDException(ErrorCodes.LOGIN_REQUIRED) }

      // We did not let client force user to login.
      // Instead, we show the information on consent page and make a sing in button if user want to change there account
      case OpenIDPrompt.LOGIN =>
        userID.map(_ => OpenIDPrompt.CONSENT)

      // TODO implementation
      case OpenIDPrompt.SELECT_ACCOUNT => Future.failed(OpenIDException(ErrorCodes.INVALID_REQUEST_OBJECT))
    } getOrElse {
      userID.flatMap(uid => checkConsentScopes(uid, validReq.clientID, validReq.scopes))
    }

  /**
    * Check status of consent
    *
    * @param userID
    * @param clientID
    * @param scopes
    * @return OpenIDPrompt =>
    *         CONSENT: need user consent
    *         NONE: generate token directly
    */
  private def checkConsentScopes(userID: String, clientID: String, scopes: Set[String]) = {
    userConsentRepository.findByUserIDAndClientID(userID, clientID)
      .map(_.exists(c => scopes.subsetOf(c.scopes.toSet)))
      .map(existed => if (existed) OpenIDPrompt.NONE else OpenIDPrompt.CONSENT)
  }

}
