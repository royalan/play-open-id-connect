package an.royal.oidc.controllers

import javax.inject._

import akka.stream.Materializer
import akka.stream.scaladsl.{Sink, Source}
import an.royal.oidc.OpenIDException
import an.royal.oidc.constants.ErrorCodes.ErrorCode
import an.royal.oidc.constants.{ErrorCodes, OpenIDDisplay, OpenIDPrompt, OpenIDResponseType}
import an.royal.oidc.dtos.ClientAuthReq
import an.royal.oidc.repositories.{Client, ClientRepository, TokenRepository, UserConsentRepository}
import an.royal.oidc.services.{SessionService, TokenService}
import io.jsonwebtoken.Claims
import play.api.Logger
import play.api.mvc._

import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Success, Try}

@Singleton
class AuthController @Inject()(userInfoAction: UserInfoAction, tokenRepository: TokenRepository, clientRepository: ClientRepository, userConsentRepository: UserConsentRepository,
                               tokenService: TokenService, sessionService: SessionService, cc: ControllerComponents)
                              (implicit mat: Materializer, ec: ExecutionContext) extends AbstractController(cc) {

  import an.royal.oidc.dtos.HttpBaseResponse._

  /**
    * 1. according to [prompt] parameter to determine let user login or not. prompt: none, login, consent, select_account
    *   1.1 none: check user has signed in by checking token in cookie, session or header, and response code or token directly.
    *   1.2 login: popup login page always.
    *   1.3 consent: check user has signed in and open consent page
    *   1.4 select_account: let user select different accounts to login.
    * 2. verify client_id with authorities. response_type, return_url, scope
    * 3. let user signed in
    * 4. user-consent screen let user confirm scope
    * 5. check response_type, code: grant code, id_token: scope in (openid), token: access token
    *   ex. token, id_token, code token, code id_token, token id_token, code token id_token, none
    * 6. respond
    *
    * @param client_id     - client ID
    * @param response_type - OpenIDResponseType
    * @param scope         - scopes own by client
    * @param redirect_uri  - redirect URI
    * @param nonce         - a random value generated by your app that enables replay protection when present and will be include in ID_TOKEN as nonce parameter.
    * @param state         - Opaque value used to maintain state between the request and the callback.
    * @param prompt        - OpenIDPrompt
    * @param display       - OpenIDDisplay
    * @return Asynchronous response
    */
  def auth(client_id: String, response_type: String, scope: String, redirect_uri: String, nonce: String,
           state: Option[String], prompt: Option[String], display: Option[String]) = userInfoAction.async { implicit req =>

    def validateReq(client: Client) =
      if (client.redirectURIs.contains(redirect_uri.trim)) {
        val validParams = for {
          validTypes <- Try(response_type.split(" +").map(_.toLowerCase).map(OpenIDResponseType.withName).toSet)
          validScopes <- Try(scope.split(" ").map(_.trim.toLowerCase).toSet).filter(_.subsetOf(client.scopes.toSet))
          validPrompt <- Try(prompt.map(OpenIDPrompt.withName))
          validDisplay <- Try(prompt.map(OpenIDDisplay.withName))
        } yield {
          ClientAuthReq(client_id, validTypes, validScopes, redirect_uri, nonce, state, validPrompt, validDisplay)
        }

        validParams match {
          case Success(r) => Right(r, client)
          case Failure(e) =>
            Logger.debug(s"Got exception while checking parameters of request $e")
            Left(ErrorCodes.INVALID_REQUEST_OBJECT)
        }
      } else {
        Left(ErrorCodes.INVALID_REDIRECT_URI)
      }


    // ------- begin -------- //
    Source.fromFuture(clientRepository.findByClientID(client_id))
      .map {
        case Some(client) => validateReq(client)
        case None =>
          Left(ErrorCodes.INVALID_CLIENT_ID)
      }
      .mapAsync(1) {
        case Right((validReq, client)) =>
          validatePrompt(validReq.prompt.getOrElse(OpenIDPrompt.CONSENT)).map {
            // Only map NONE and CONSENT, others would be non implemented exception
            case OpenIDPrompt.NONE =>

              // TODO check response_type? should we manage it?
              validReq.responseTypes
                .filter(_ != OpenIDResponseType.NONE)
                .map {
                  case OpenIDResponseType.CODE => tokenService.createGrantCode(validReq.clientID)
                  case OpenIDResponseType.TOKEN => tokenService.createAccessToken(req.userID)
                  case OpenIDResponseType.ID_TOKEN => tokenService.createIDToken(req.userID, validReq.clientID)
                }
              // TODO make query string then respond


              Ok("It's NONE prompt!!")

            case OpenIDPrompt.CONSENT =>
              // TODO make consent form
              Logger.debug(s"Pre-request URI: ${req.uri}")
              Ok(views.html.consent()).withSession(req.session + ("preReq" -> req.uri))
          }
        case Left(err) => Future.successful(
          if (err == ErrorCodes.INVALID_REDIRECT_URI)
            errorResponse(BAD_REQUEST, err)
          else
            Redirect(redirect_uri, authErrorQueryParams(err, state), BAD_REQUEST))
      }
      .runWith(Sink.head)
      .recover {
        case OpenIDException(code, msg) => errorResponse(BAD_REQUEST, code, msg)
        case t: Throwable =>
          Logger.error(s"Unexpected exception $t")
          errorResponse(INTERNAL_SERVER_ERROR, ErrorCodes.UNKNOWN_ERROR)
      }
  }


  // ---------------- common functions -------------------- //

  private def authErrorQueryParams(errorCode: ErrorCode, state: Option[String]): Map[String, Seq[String]] = state match {
    case Some(s) => Map("error" -> Seq(errorCode.toString.toLowerCase), "state" -> Seq(s))
    case None => Map("error" -> Seq(errorCode.toString.toLowerCase))
  }


  private def validatePrompt(prompt: OpenIDPrompt.Prompt)(implicit request: Request[_]): Future[OpenIDPrompt.Prompt] =
    prompt match {
      case OpenIDPrompt.NONE =>

        sessionService.checkSession(request.session.get("sessionID"), request.cookies.get("token").map(_.value))
          .flatMap {
            case Success(claims: Claims) =>

              val validScopesResult: Option[Future[OpenIDPrompt.Prompt]] =
                for {
                  userID <- Option(claims.getSubject)
                  clientID <- request.getQueryString("client_id")
                  scopes <- request.getQueryString("scope").map(_.toLowerCase.split(" +").toSet)
                } yield {
                  userConsentRepository.findByUserIDAndClientID(userID, clientID)
                    .filter(_.exists(c => scopes.subsetOf(c.scopes.toSet)))
                    .flatMap {
                      case Some(_) => Future.successful(OpenIDPrompt.NONE)
                      case None => Future.failed(OpenIDException(ErrorCodes.CONSENT_REQUIRED))
                    }
                }

              validScopesResult.getOrElse(Future.failed(OpenIDException(ErrorCodes.CONSENT_REQUIRED, Some("User not yet consent the scopes"))))
            case _ => Future.failed(OpenIDException(ErrorCodes.LOGIN_REQUIRED))
          }

      case OpenIDPrompt.CONSENT =>
        // check session, not need to check scopes
        sessionService.checkSession(request.session.get("sessionID"), request.cookies.get("token").map(_.value))
          .map {
            case Success(_) => OpenIDPrompt.CONSENT
            case _ => throw OpenIDException(ErrorCodes.LOGIN_REQUIRED)
          }

      // We did not let client force user to login.
      // Instead, we show the information on consent page and make a sing in button if user want to change there account
      case OpenIDPrompt.LOGIN => Future.failed(OpenIDException(ErrorCodes.INVALID_REQUEST_OBJECT))

      // TODO implementation
      case OpenIDPrompt.SELECT_ACCOUNT => Future.failed(OpenIDException(ErrorCodes.INVALID_REQUEST_OBJECT))
    }


}
