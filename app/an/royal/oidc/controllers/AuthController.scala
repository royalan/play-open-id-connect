package an.royal.oidc.controllers

import javax.inject._

import akka.actor.ActorSystem
import akka.stream.Materializer
import akka.stream.scaladsl.{Sink, Source}
import an.royal.oidc.constants.{ErrorCodes, OpenIDDisplay, OpenIDPrompt, OpenIDResponseType}
import an.royal.oidc.dtos.ClientAuthReq
import an.royal.oidc.repositories.{ClientRepository, UserConsentRepository}
import an.royal.oidc.services.ISessionService
import play.api.mvc._

import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Success, Try}

@Singleton
class AuthController @Inject()(sesssionService: ISessionService, userInfoAction: UserInfoAction, cc: ControllerComponents,
                               actorSystem: ActorSystem, clientRepository: ClientRepository, userConsentRepository: UserConsentRepository)
                              (implicit mat: Materializer, ec: ExecutionContext) extends AbstractController(cc) {

  import an.royal.oidc.dtos.HttpBaseResponse._

  /**
    * 1. according to [prompt] parameter to determine let user login or not. prompt: none, login, consent, select_account
    *   1.1 none: check user has signed in by checking token in cookie, session or header, and response code or token directly.
    *   1.2 login: popup login page always.
    *   1.3 consent: check user has signed in and open consent page
    *   1.4 select_account: let user select different accounts to login.
    * 2. verify client_id with authorities. response_type, return_url, scope
    * 3. let user signed in
    * 4. user-consent screen let user confirm scope
    * 5. check response_type, code: grant code, id_token: scope in (openid), token: access token
    *   ex. token, id_token, code token, code id_token, token id_token, code token id_token, none
    * 6. respond
    *
    * @param client_id     - client ID
    * @param response_type - OpenIDResponseType
    * @param scope         - scopes own by client
    * @param redirect_uri  - redirect URI
    * @param nonce         - a random value generated by your app that enables replay protection when present and will be include in ID_TOKEN as nonce parameter.
    * @param state         - Opaque value used to maintain state between the request and the callback.
    * @param prompt        - OpenIDPrompt
    * @param display       - OpenIDDisplay
    * @return Asynchronous response
    */
  def auth(client_id: String, response_type: String, scope: String, redirect_uri: String, nonce: String,
           state: Option[String], prompt: Option[String], display: Option[String]) = userInfoAction.async { req =>

    // TODO check response_type? should we manage it?

    Source.fromFuture(clientRepository.findByClientID(client_id)).map {
      case Some(client) =>
        if (client.redirectURIs.contains(redirect_uri.trim)) {
          val validTypes = Try(response_type.split(" ").map(_.trim.toLowerCase).map(OpenIDResponseType.withName).toSet)
          val validScopes = Try(scope.split(" ").map(_.trim.toLowerCase).toSet).filter(_.subsetOf(client.scopes.toSet))
          val validPrompt = Try(prompt.map(OpenIDPrompt.withName))
          val validDisplay = Try(prompt.map(OpenIDDisplay.withName))

          if (validTypes.isFailure)
            Left(ErrorCodes.INVALIDE_RESPONSE_TYPE)
          else if (validScopes.isFailure)
            Left(ErrorCodes.INVALID_SCOPE)
          else if (!client.redirectURIs.contains(redirect_uri))
            Left(ErrorCodes.INVALID_REDIRECT_URI)
          else if (validPrompt.isFailure)
            Left(ErrorCodes.INVALID_PROMPT)
          else if (validDisplay.isFailure)
            Left(ErrorCodes.INVALID_DISPLAY)
          else
            Right(ClientAuthReq(client_id, validTypes.get, validScopes.get, redirect_uri, nonce, state, validPrompt.get, validDisplay.get), client)
        } else {
          Left(ErrorCodes.INVALID_REDIRECT_URI)
        }
      case None =>
        Left(ErrorCodes.INVALID_CLIENT_ID)
    }.map {
      case Right((validReq, client)) =>
        // FIXME don't forget prompt and display
        userConsentRepository.findByUserIDAndClientID(req.userID, client_id).map {
          case Some(c) =>
            validReq.prompt.map {
              case OpenIDPrompt.NONE =>
                if (validReq.scopes.subsetOf(c.scopes.toSet))
                  ???
                // response token
                else
                  errorResponse(BAD_REQUEST, ErrorCodes.ILLEGAL_STATE_OF_PROMPT_VALUE, Some(s"Checked state failed of prompt value [none]"))
              case OpenIDPrompt.LOGIN =>

              case OpenIDPrompt.CONSENT =>
              case OpenIDPrompt.SELECT_ACCOUNT =>
            }


          // TODO implementation
          // response toke, id_token, code directly

          // should keep response_type, scopes, client_id, redirect_uri, state... etc. to consent page
          case None => Ok(views.html.consent())
        }
      case Left(err) =>
        errorResponse(BAD_REQUEST, err)
    }


    Source.single((client_id, response_type, redirect_uri, scope, nonce, state))
      .map(t => Ok(t.productIterator.mkString(", ")))
      .runWith(Sink.head)


  }

  def promptValidation[A](action: Action[A]) = Action.async(action.parser) { request =>
    import an.royal.oidc.constants.OpenIDConstants._
    import an.royal.oidc.constants.OpenIDPrompt._

    Try(request.getQueryString("prompt").map(OpenIDPrompt.withName).map {
      case NONE =>
        // check session
        // check scopes
        sesssionService.checkSession(request.session.get(SESSION_ID), request.cookies.get(TOKEN).map(_.value))
        Ok
      case LOGIN =>
      // redirect to login directly
        Ok
      case CONSENT =>
      // check session, not check scopes
        Ok
      case SELECT_ACCOUNT =>
        errorResponse(BAD_REQUEST, ErrorCodes.NOT_YET_IMPLEMENTED, Some("select_account of prompt value not yep implemented"))
    }) match {
      case Success(Some(result)) => Future.successful(result)
      case Failure(_) => Future.successful(errorResponse(BAD_REQUEST, ErrorCodes.INVALID_PROMPT))
      case _ => action(request)
    }
  }


}
