package an.royal.oidc.controllers

import javax.inject._

import akka.actor.ActorSystem
import akka.stream.Materializer
import akka.stream.scaladsl.{Sink, Source}
import an.royal.oidc.constants.{ErrorCodes, OpenIDDisplay, OpenIDPrompt, OpenIDResponseType}
import an.royal.oidc.dtos.ClientAuthReq
import an.royal.oidc.repositories.{ClientRepository, UserConsentRepository}
import play.api.mvc._

import scala.concurrent.ExecutionContext
import scala.util.Try

@Singleton
class AuthController @Inject()(userInfoAction: UserInfoAction, cc: ControllerComponents, actorSystem: ActorSystem, clientRepository: ClientRepository, userConsentRepository: UserConsentRepository)
                              (implicit mat: Materializer, exec: ExecutionContext) extends AbstractController(cc) {

  import an.royal.oidc.dtos.HttpBaseResponse._

  /**
    * 1. according to [prompt] parameter to determine let user login or not. prompt: none, login, consent, select_account
    *   1.1 none: check user has signed in by checking token in cookie, session or header, and response code or token directly.
    *   1.2 login: popup login page always.
    *   1.3 consent: check user has signed in and open consent page
    *   1.4 select_account: let user select different accounts to login.
    * 2. verify client_id with authorities. response_type, return_url, scope
    * 3. let user signed in
    * 4. user-consent screen let user confirm scope
    * 5. check response_type, code: grant code, id_token: scope in (openid), token: access token
    *   ex. token, id_token, code token, code id_token, token id_token, code token id_token, none
    * 6. respond
    *
    * @param client_id     - client ID
    * @param response_type - OpenIDResponseType
    * @param scope         - scopes own by client
    * @param redirect_uri  - redirect URI
    * @param nonce         - a random value generated by your app that enables replay protection when present and will be include in ID_TOKEN as nonce parameter.
    * @param state         - Opaque value used to maintain state between the request and the callback.
    * @param prompt        - OpenIDPrompt
    * @param display       - OpenIDDisplay
    * @return Asynchronous response
    */
  def auth(client_id: String, response_type: String, scope: String, redirect_uri: String, nonce: String,
           state: Option[String], prompt: Option[String], display: Option[String]) = userInfoAction.async { req =>

    Source.fromFuture(clientRepository.findByClientID(client_id)).map {
      case Some(client) =>
        if (client.redirectURIs.contains(redirect_uri.trim)) {
          val validTypes = Try(response_type.split(" ").map(_.trim.toLowerCase).map(OpenIDResponseType.withName).toSet)
          val validScopes = Try(scope.split(" ").map(_.trim.toLowerCase).toSet).filter(_.subsetOf(client.scopes.toSet))
          val validPrompt = Try(prompt.map(OpenIDPrompt.withName))
          val validDisplay = Try(prompt.map(OpenIDDisplay.withName))

          if (validTypes.isFailure)
            Left(ErrorCodes.INVALIDE_RESPONSE_TYPE)
          else if (validScopes.isFailure)
            Left(ErrorCodes.INVALID_SCOPE)
          else if (!client.redirectURIs.contains(redirect_uri))
            Left(ErrorCodes.INVALID_REDIRECT_URI)
          else if (validPrompt.isFailure)
            Left(ErrorCodes.INVALID_PROMPT)
          else if (validDisplay.isFailure)
            Left(ErrorCodes.INVALID_DISPLAY)
          else
            Right(ClientAuthReq(client_id, validTypes.get, validScopes.get, redirect_uri, nonce, state, validPrompt.get, validDisplay.get), client)
        } else {
          Left(ErrorCodes.INVALID_REDIRECT_URI)
        }
      case None =>
        Left(ErrorCodes.INVALID_CLIENT_ID)
    }.map {
      case Right((validReq, client)) =>
        userConsentRepository.findByUserIDAndClientID(req.userID, client_id).map{
          case Some(c) if validReq.scopes.subsetOf(c.scopes.toSet) =>
          // TODO implementation
          // response toke, id_token, code directly

          // should keep response_type, scopes, client_id, redirect_uri... etc. to consent page
          case _ => Ok(views.html.consent)
        }
      case Left(err) =>
        errorResponse(BAD_REQUEST, err, None)
    }


    Source.single((client_id, response_type, redirect_uri, scope, nonce, state))
      .map(t => Ok(t.productIterator.mkString(", ")))
      .runWith(Sink.head)


  }


}
