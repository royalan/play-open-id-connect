package an.royal.oidc.controllers

import java.util.NoSuchElementException
import javax.inject._

import akka.actor.ActorSystem
import akka.stream.Materializer
import akka.stream.scaladsl.{Sink, Source}
import an.royal.oidc.constants.{ErrorCodes, OpenIDResponseType}
import an.royal.oidc.repositories.ClientRepository
import play.api.Logger
import play.api.mvc._

import scala.concurrent.{ExecutionContext, Future}

/**
  * This controller creates an `Action` that demonstrates how to write
  * simple asynchronous code in a controller. It uses a timer to
  * asynchronously delay sending a response for 1 second.
  *
  * @param cc          standard controller components
  * @param actorSystem We need the `ActorSystem`'s `Scheduler` to
  *                    run code after a delay.
  * @param exec        We need an `ExecutionContext` to execute our
  *                    asynchronous code.  When rendering content, you should use Play's
  *                    default execution context, which is dependency injected.  If you are
  *                    using blocking operations, such as database or network access, then you should
  *                    use a different custom execution context that has a thread pool configured for
  *                    a blocking API.
  */
@Singleton
class AuthController @Inject()(userInfoAction: UserInfoAction, cc: ControllerComponents, actorSystem: ActorSystem, clientRepository: ClientRepository)
                              (implicit mat: Materializer, exec: ExecutionContext) extends AbstractController(cc) {

  import an.royal.oidc.dtos.HttpBaseResponse._

  /**
    * 1. according to [prompt] parameter to determine let user login or not. prompt: none, login, consent, select_account
    *   1.1 none: check user has signed in by checking token in cookie, session or header, and response code or token directly.
    *   1.2 login: popup login page always.
    *   1.3 consent: check user has signed in and open consent page
    *   1.4 select_account: let user select different accounts to login.
    * 2. verify client_id with authorities. response_type, return_url, scope
    * 3. let user signed in
    * 4. user-consent screen let user confirm scope
    * 5. check response_type, code: grant code, id_token: scope in (openid), token: access token
    *   ex. token, id_token, code token, code id_token, token id_token, code token id_token, none
    * 6. respond
    *
    * @param client_id - client ID
    * @param response_type - OpenIDResponseType
    * @param scope - scopes own by client
    * @param redirect_uri - redirect URI
    * @param nonce - a random value generated by your app that enables replay protection when present.
    * @param state - used to associate a Client session with an ID Token and will be include in ID_TOKEN for validation
    * @param prompt - OpenIDPrompt
    * @param display - OpenIDDisplay
    * @return Asynchronous response
    */
  def auth(client_id: String, response_type: String, scope: String, redirect_uri: String, nonce: String,
           state: Option[String], prompt: Option[String], display: Option[String]) = userInfoAction.async { req =>
    try {
      // check response type
      val respTypes = response_type.split(" ").map(_.trim).map(OpenIDResponseType.withName).toSet
      val scopes = scope.split(" ").map(_.trim).toSet

      Source.fromFuture(clientRepository.findByClientID(client_id)).map { // check redirect URI and scopes
        _.filter(c => c.redirectURIs.contains(redirect_uri.trim) && scopes.subsetOf(c.scopes.toSet))
      }.runWith(Sink.head)

      // check session for login


    } catch {
      case e: NoSuchElementException =>
        Logger.debug(s"Got NoSuchElementException, message: ${e.getMessage}")
        Future.successful(errorResponse(BAD_REQUEST, ErrorCodes.INVALID_OPEN_ID_RESPONSE_TYPE, Some(s"response_type not valid: [$response_type]")))
    }


    Source.single((client_id, response_type, redirect_uri, scope, nonce, state))
      .map(t => Ok(t.productIterator.mkString(", ")))
      .runWith(Sink.head)
  }

}
