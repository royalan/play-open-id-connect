package an.royal.oidc.controllers

import javax.inject._

import akka.stream.Materializer
import akka.stream.scaladsl.{Sink, Source}
import an.royal.oidc.constants.ErrorCodes.ErrorCode
import an.royal.oidc.constants.{ErrorCodes, OpenIDDisplay, OpenIDPrompt, OpenIDResponseType}
import an.royal.oidc.dtos.{ClientAuthReq, ScopeDTO, UserConsentDetail, UserConsentReq}
import an.royal.oidc.repositories._
import an.royal.oidc.services.{SessionService, TokenPayload, TokenService}
import an.royal.oidc.{InvalidSessionException, OpenIDException}
import play.api.Logger
import play.api.data.Form
import play.api.data.Forms._
import play.api.mvc._

import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Success, Try}

@Singleton
class AuthController @Inject()(userInfoAction: UserInfoAction, tokenRepository: TokenRepository, clientRepository: ClientRepository, userConsentRepository: UserConsentRepository,
                               scopeRepository: ScopeRepository, userRepository: UserRepository, tokenService: TokenService, sessionService: SessionService, cc: ControllerComponents)
                              (implicit mat: Materializer, ec: ExecutionContext) extends AbstractController(cc) {

  import an.royal.oidc.dtos.HttpBaseResponse._

  val userConsentForm = Form(
    mapping(
      "clientID" -> text,
      "scopes" -> text
    )(UserConsentReq.apply)(UserConsentReq.unapply))

  /**
    * @param client_id     - client ID
    * @param response_type - OpenIDResponseType
    * @param scope         - scopes own by client
    * @param redirect_uri  - redirect URI
    * @param nonce         - a random value generated by your app that enables replay protection when present and will be include in ID_TOKEN as nonce parameter.
    * @param state         - Opaque value used to maintain state between the request and the callback.
    * @param prompt        - OpenIDPrompt
    * @param display       - OpenIDDisplay
    * @return Asynchronous response
    */
  def auth(client_id: String, response_type: String, scope: String, redirect_uri: String, nonce: String,
           state: Option[String], prompt: Option[String], display: Option[String]): Action[AnyContent] = Action.async { implicit req =>

    def validateReq(client: Client) =
      if (client.redirectURIs.contains(redirect_uri.trim)) {
        val validParams = for {
          validTypes <- Try(response_type.split(" +").map(_.toLowerCase).map(OpenIDResponseType.withName).toSet)
          validScopes <- Try(scope.split(" ").map(_.trim.toLowerCase).toSet).filter(_.subsetOf(client.scopes.toSet))
          validPrompt <- Try(prompt.map(OpenIDPrompt.withName))
          validDisplay <- Try(display.map(OpenIDDisplay.withName))
        } yield {
          ClientAuthReq(client_id, validTypes, validScopes, redirect_uri, nonce, state, validPrompt, validDisplay)
        }

        validParams match {
          case Success(r) => Right(r, client)
          case Failure(e) =>
            Logger.debug("Got exception while checking parameters of request.", e)
            Left(ErrorCodes.INVALID_REQUEST_OBJECT)
        }
      } else {
        Left(ErrorCodes.INVALID_REDIRECT_URI)
      }


    // ------------------- begin --------------------- //
    Source.fromFuture(clientRepository.findByClientID(client_id))
      .map {
        case Some(client) => validateReq(client)
        case None =>
          Left(ErrorCodes.INVALID_CLIENT_ID)
      }
      .mapAsync(1) {
        case Right((validReq, client)) =>

          val userID = sessionService.checkSession(req.session.get("sessionID"), req.cookies.get("token").map(_.value)).map(_.getSubject)

          validatePrompt(validReq, userID).flatMap {
            case OpenIDPrompt.NONE =>

              lazy val tokenPayload = userID.map(uid => TokenPayload(validReq.clientID, uid, validReq.scopes, validReq.redirectURI))

              // TODO check response_type? should we manage it?
              val tokens = validReq.responseTypes
                .filter(_ != OpenIDResponseType.NONE)
                .map {
                  case OpenIDResponseType.CODE => tokenPayload.flatMap(tokenService.createGrantCode).map("code" -> Seq(_))
                  case OpenIDResponseType.TOKEN => tokenPayload.flatMap(tokenService.createAccessToken(_, None)).map("token" -> Seq(_))
                  case OpenIDResponseType.ID_TOKEN => userID.flatMap(uid => tokenService.createIDToken(uid, validReq.clientID, nonce)).map("id_token" -> Seq(_))
                }

              Future.sequence(tokens)
                .map(qSet => state.map(s => qSet + ("state" -> Seq(s))).getOrElse(qSet))
                .map(qSet =>
                  if (qSet.exists(q => q._1 == "token" || q._1 == "id_token"))
                    Redirect(Call("get", redirect_uri, qSet.foldLeft("")((o, v) => o + s"${v._1}=${v._2.head}&").dropRight(1)))
                  else
                    Redirect(redirect_uri, qSet.toMap)
                )

            // FIXME if the scopes have been consent, should we prompt again?
            case OpenIDPrompt.CONSENT =>
              Logger.debug(s"Pre-request URI: ${req.uri}")

              for {
                scopeDescs <- Future.sequence(validReq.scopes.map(scopeRepository.findByName)).map(_.filter(_.isDefined).map(_.map(s => ScopeDTO(s.name, s.description)).get))
                uid <- userID
                userOpt <- userRepository.findByUserID(uid)
              } yield {
                userOpt.map(u => UserConsentDetail(u.name, u.avatar, u.email, client.logoURI, client.homepageURI, client.name, client.termsOfServiceURI, client.privacyPolicyURI, scopeDescs))
                  .map(detail =>
                    Ok(views.html.consent(detail, userConsentForm.bind(Map("clientID" -> client_id, "scopes" -> scope))))
                      .withSession(req.session + ("preReq" -> req.uri)))
                  .getOrElse(errorResponse(BAD_REQUEST, ErrorCodes.USER_NOT_FOUND))
              }
          }

        case Left(err) => Future.successful(
          if (err == ErrorCodes.INVALID_REDIRECT_URI)
            errorResponse(BAD_REQUEST, err)
          else
            Redirect(redirect_uri, authErrorQueryParams(err, state)))
      }
      .runWith(Sink.head)
  }

  def consentToClientScopes: Action[AnyContent] = userInfoAction.async { implicit request =>
    val successFunc = { userConsent: UserConsentReq =>
      Logger.debug(s"$userConsent")
      userConsentRepository.findByUserIDAndClientID(request.userID, userConsent.clientID)
        .map { optUC =>
          val scopes = userConsent.scopes.split(" +").toList
          optUC.map(uc => uc.copy(scopes = (uc.scopes ::: scopes).distinct))
            .getOrElse(UserConsent(request.userID, userConsent.clientID, scopes, System.currentTimeMillis, System.currentTimeMillis, false))
        }
        .flatMap(userConsentRepository.insertOrUpdate)
        // TODO we can generate token or code directly?
        .map(_ => Redirect(request.session("preReq")))
    }

    val errorFunc = { form: Form[UserConsentReq] =>
      form.errors.foreach(err => Logger.warn(s"${err.key}: ${err.message}"))
      Future.successful {
        Redirect(request.session("preReq"))
      }
    }

    userConsentForm.bindFromRequest().fold(errorFunc, successFunc)
  }


  // ---------------- common functions -------------------- //

  private def authErrorQueryParams(errorCode: ErrorCode, state: Option[String]): Map[String, Seq[String]] = state match {
    case Some(s) => Map("error" -> Seq(errorCode.toString.toLowerCase), "state" -> Seq(s))
    case None => Map("error" -> Seq(errorCode.toString.toLowerCase))
  }


  /**
    * Validate prompt value, if error, just throw exception.
    *
    * @param validReq
    * @param userID - with throw InvalidSessionException while fail
    * @return Future[OpenIDPrompt.Prompt]
    * @throws OpenIDException , InvalidSessionException
    */
  private def validatePrompt(validReq: ClientAuthReq, userID: Future[String]): Future[OpenIDPrompt.Prompt] =
    validReq.prompt map {
      case OpenIDPrompt.NONE =>
        userID.flatMap(uid => checkConsentScopes(uid, validReq.clientID, validReq.scopes))
          .map {
            case OpenIDPrompt.CONSENT => throw OpenIDException(ErrorCodes.CONSENT_REQUIRED)
            case OpenIDPrompt.LOGIN => throw OpenIDException(ErrorCodes.LOGIN_REQUIRED)
            case p => p
          }.recover { case _: InvalidSessionException => throw OpenIDException(ErrorCodes.LOGIN_REQUIRED) }

      case OpenIDPrompt.CONSENT =>
        userID.map(_ => OpenIDPrompt.CONSENT).recover { case _: InvalidSessionException => throw OpenIDException(ErrorCodes.LOGIN_REQUIRED) }

      case OpenIDPrompt.LOGIN =>
        userID.flatMap(uid => checkConsentScopes(uid, validReq.clientID, validReq.scopes))

      // TODO implementation
      case OpenIDPrompt.SELECT_ACCOUNT => Future.failed(OpenIDException(ErrorCodes.INVALID_REQUEST_OBJECT))
    } getOrElse {
      userID.flatMap(uid => checkConsentScopes(uid, validReq.clientID, validReq.scopes))
    }

  /**
    * Check status of consent
    *
    * @param userID
    * @param clientID
    * @param scopes
    * @return OpenIDPrompt =>
    *         CONSENT: need user consent
    *         NONE: generate token directly
    */
  private def checkConsentScopes(userID: String, clientID: String, scopes: Set[String]) = {
    userConsentRepository.findByUserIDAndClientID(userID, clientID)
      .map(_.exists(c => scopes.subsetOf(c.scopes.toSet)))
      .map(existed => if (existed) OpenIDPrompt.NONE else OpenIDPrompt.CONSENT)
  }

}
